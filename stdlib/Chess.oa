# chess.oa
# ========

use oa.Matrix

trait Piece = $Rook
            + $Knight
			+ $Bishop
			+ $Queen
			+ $King
			+ $Pawn

trait Board = {
	let show =

	let board: $Matrix[$Piece] size == (8, 8) =
	let player-to-move: $Player.white
	let players-allowed-to-castle = (
		$WHITE => ('kingside, 'queenside),
		$BLACK => ($KINGSIDE, 'queenside), )
	let result: $Future
	let history = $History


	let attemp-move | move: $Move = {
		if ($legal-moves contains $move) {
		} else {

		}
	}

	let after | move: $Move
	          |: $legal-moves contains $move = {
		if $move is-castling {
			$players-allowed-to-castle

			$player-to-move
		} else {
			$board [$move 0] = ()
			$board [$move 1] = $move piece }}}

trait Board: $Format = {
	let show = {

	} }

trait History | game: $Game {
	let moves: $Coordinate => $Coordinate = ()

	let number-of-moves-without-capture-or-pawn-move = {
		$rewind-board reverse }

	let rewind-board = $Game board fold ($Game, _ after _)
}

trait Game ( board: $Board,
             history: $History,
		     white: $Player,
		     black: $Player, )

trait Clock: $Default {
	let active: $Player = $WHITE
	let delay: $Duration
	let white: $Stopwatch = $Stopwatch new
	let black: $Stopwatch = $Stopwatch new

	let default = $Clock ()

	let press = {  }}

trait Player {
	let move: $Move

	let accept-draw: $Bool

	let offer-draw

	let resign
}

trait Move = (
	offer-draw = $Bool,
)

trait Bishop: $Piece + $fmt.Format {
	let symbol = "b"

	let range = $chessboard filter (
		c => $position zip $c map '- )}

trait Bishop: $Piece {
	let symbol = "b"
	let range = $chessboard filter (
		c => $position zip $c map '- )}

trait Rook: $Piece {
	let symbol = "r"
	let range = $chessboard filter (
		c => $position zip $c map '== )}

trait Queen: $Piece {
	let symbol = "q"
	let range = $chessboard filter (
		c => $position zip $c map '- )}

trait King: $Piece {
	let symbol = "k"
	let range = (-1..2, -1..2)
		}

trait Knight: $Piece {
	let symbol = "n"
	let range = (1..5) map ($c )
)

crate Game {
	let from
}
